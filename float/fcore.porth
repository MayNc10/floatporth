include "core.porth" 
const NaN 2139095041 end
const qNaN 2139095041 end
const sNaN 4290772993 end
const inf 2139095040 end
const -inf 4286578688 end
const +zero 0 end
const -zero 2147483648 end

const mantMask 8388607 end
const mantMin 8388608 end
const expMask 2147483647 end
const signBit 2147483648 end

const overflowMask 4294967295 end

//NOTE: still trying to figure out a good name for the 'reduceTo' functions
proc getSign int -- int int in
  dup 31 shr
end
proc reduceToSign int -- int in
  31 shr
end
proc setSign int int -- int in //float and sign
  swap expMask and swap 31 shl or
end

proc getExp int -- int int in
  dup expMask and 23 shr 127 -
end
proc reduceToExp int -- int in
  expMask and 23 shr 127 -
end
proc setExp int int -- int in
  127 + swap //e f
  getSign swap rot swap // s e f
  dup mantMask and swap //s e m f
  32 shr 7 shl //s e m f
  rot  //s m f e
  + //s m f
  23 shl //s m f
  + + //f
end

proc getMant int -- int int in
  dup mantMask and
end
proc reduceToMant int -- int in
  mantMask and
end
proc setMant int int -- int in
  swap 22 shr 22 shl or
end

proc tofloat int -- int in //doesnt handle negative ints
     dup 0 != if //if zero, just leave zero on stack
       false swap
       dup 0 < if
         neg //TODO: when we update, this should be neg
         swap drop true swap //reset bool
       end
       0 0 //exp and mantissa
       rot
       //stack looks like exp mant n
       while dup 1 > do
         dup 1 and //bit = n & 1
         swap
         1 shr //n >> 1
         rot // bit n mant
         1 shr //mant >> 1
         rot //n mant bit
         22 shl //exp n mant bit
         + //exp n mant
         rot //n mant exp
         1 + //n mant exp
         swap rot //exp mant n
       end
       //maybe round
       drop //exp mant
       mantMask and //mant bitmask// 
       swap //mant exp
       127 +
       23 shl
       + //final float w/o sign
       swap 0 swap if //negative
         drop 1
       end
       31 shl + //final float
     end
end

proc toint int -- int in
  dup 0 != if //same as tofloat
   getSign swap getExp   //s f e
   1 22 //keep track of number and count
   rot //s f n c e
   while dup 0 > do
    let f n c e in
     0 c 0 > if drop f c shr 1 and end //get the last bit of f
     f swap //f b
     n 1 shl //f b n
     + //f n
     c 1 -
     e 1 -
    end
   end
   drop drop swap drop //s n
   swap 0 > if not 1 + end //TODO: again, neg
  end
end
  
inline proc fNeg int -- int in
  2147483648 + //1<<31
  overflowMask and //bitmask
end

inline proc fAbs int -- int in
  expMask and //bitmask
end

inline proc fCopysign int int -- int in
  signBit and
  swap 
  expMask and //bitmask sign bit
  +
  overflowMask and
end

inline proc fIsNeg int -- bool in
  2147483647 >
end

inline proc fIsPos int -- bool in
  expMask <
end

inline proc fIsNaN int -- bool in
  dup dup inf >  swap -zero < land swap -inf != land   
end

inline proc fSign int -- int in //NOTE: should this return 1 for -0? I don't think so, so it doesn't
  fIsPos if
    1 tofloat
  else
    -1 tofloat
  end
end

inline proc convZeros int int -- int int in
  dup -zero = if
     drop +zero
  end 
  over -zero = if 
     drop +zero 
  end
end

inline proc eitherNan int int -- int int bool in
  over fIsNaN over fIsNaN lor
end

proc f< int int -- bool in
  eitherNan if
    drop drop false
  else
    convZeros
    over over
    fIsNeg swap fIsNeg land if //check if both negative
      //if both negative, we actually want f1 to be greater (because a greater negative is smaller)
      >
    else
      <
    end
  end
end

proc f> int int -- bool in
  eitherNan if
    drop drop false
  else
    convZeros
    //same as f<
    fNeg swap fNeg swap
    over over
    fIsPos swap fIsPos land if
      <
    else
      >
    end
  end
end

proc f>= int int -- bool in
  eitherNan if
    drop drop false
  else
    f< lnot
  end
end

proc f<= int int -- bool in
  eitherNan if
    drop drop false
  else
    f> lnot
  end
end

proc f= int int -- bool in
  eitherNan if
    drop drop false
  else
    convZeros
    =
  end
end

proc f!= int int -- bool in
  eitherNan if
    drop drop true
  else
    convZeros
    !=
  end
end

proc fNextAfter int int -- int in //NOTE: this function returns the same numbers for +0 and -0
  let f1 f2 in
    f1 f2 = if
      f1
    else
      f1 0 f= f1 fSign f2 fSign != land if
        f2 fSign 1 = if
          1
        else
          2147483649 //largest number greater than zero
        end
      else
        f1 f2 f> if
          f1 1 - 
        else
          f1 1 +
        end
      end
    end
  end
end

proc fNextTo int -- int int int in //NOTE: this function returns the same numbers for +0 and -0
  dup 0 f= if
    2147483649 1 //numbers next to 0
  else
    dup 1 + dup 1 - 
  end
end

    

    

